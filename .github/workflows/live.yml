name: Build Custom Debian Live ISO

on:
  push:
    branches: [ main, master ]
    paths-ignore:
      - '**.md'
      - 'docs/**'
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:
    inputs:
      debug:
        type: boolean
        description: 'Enable tmate debugging session'
        required: false
        default: false

jobs:
  build-iso:
    runs-on: ubuntu-latest
    timeout-minutes: 120  # Build may take considerable time

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0  # Full history for versioning

      # Setup environment variables
      - name: Configure build environment
        id: config
        run: |
          echo "TIMESTAMP=$(date +%Y%m%d%H%M)" >> $GITHUB_ENV
          echo "DEBIAN_FRONTEND=noninteractive" >> $GITHUB_ENV
          echo "SOURCE_DATE_EPOCH=$(git log -1 --pretty=%ct)" >> $GITHUB_ENV
          echo "BUILD_DIR=${{ github.workspace }}/build" >> $GITHUB_ENV
          # Generate an ISO name based on repo name or custom name from config
          REPO_NAME=$(echo "${{ github.repository }}" | awk -F '/' '{print $2}')
          echo "ISO_NAME=${REPO_NAME}-live-$(date +%Y%m%d)" >> $GITHUB_ENV

      # Install required dependencies
      - name: Install live-build and dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            live-build \
            xorriso \
            isolinux \
            syslinux-common \
            debootstrap \
            squashfs-tools \
            wget \
            curl \
            ca-certificates \
            jq \
            mmdebstrap \
            apt-utils

      # Enable tmate debugging if requested
      - name: Setup tmate debug session
        uses: mxschmitt/action-tmate@v3
        if: ${{ github.event_name == 'workflow_dispatch' && inputs.debug }}
        with:
          limit-access-to-actor: true

      # Validate configuration 
      - name: Validate live-build configuration
        id: validate
        run: |
          # Check if auto/ directory exists, otherwise use default setup
          if [ ! -d "auto" ]; then
            echo "::warning::No auto/ directory found, using default configuration"
            mkdir -p auto
            
            # Create minimal auto/config script
            cat > auto/config << 'EOF'
          #!/bin/sh
          set -e
          lb config noauto \
            --distribution sid \
            --architectures amd64 \
            --binary-images iso-hybrid \
            --debian-installer live \
            --debian-installer-gui true \
            --archive-areas "main contrib non-free non-free-firmware" \
            --apt-indices false \
            --security true \
            --updates true \
            --source false \
            --bootappend-live "boot=live components locales=en_US.UTF-8" \
            "${@}"
          EOF
            chmod +x auto/config
          fi
          
          # Check for package lists
          if [ ! -d "config/package-lists" ]; then
            echo "::warning::No package lists found, creating minimal package list"
            mkdir -p config/package-lists
            echo "task-xfce-desktop" > config/package-lists/desktop.list.chroot
            echo "linux-image-amd64" > config/package-lists/kernel.list.chroot
            echo "firmware-linux" >> config/package-lists/kernel.list.chroot
          fi
          
          # Validate auto/config is executable
          if [ -f "auto/config" ] && [ ! -x "auto/config" ]; then
            echo "::error::auto/config exists but is not executable"
            chmod +x auto/config
          fi

      # Clean previous build artifacts if they exist
      - name: Clean build environment
        run: |
          # Create or clean build directory
          mkdir -p ${{ env.BUILD_DIR }}
          
          # If lb exists, run lb clean
          if command -v lb &> /dev/null; then
            lb clean --purge
          fi

      # Initialize live-build configuration
      - name: Initialize live-build configuration
        working-directory: ${{ env.BUILD_DIR }}
        run: |
          # Copy configuration from repo to build directory
          cp -r ${{ github.workspace }}/auto ${{ env.BUILD_DIR }}/ || true
          mkdir -p ${{ env.BUILD_DIR }}/config
          cp -r ${{ github.workspace }}/config/* ${{ env.BUILD_DIR }}/config/ || true
          
          # Initialize configuration
          if [ -f "auto/config" ]; then
            ./auto/config
          else
            echo "::error::Could not find auto/config after preparation"
            exit 1
          fi

      # Build the live system
      - name: Build live system ISO
        working-directory: ${{ env.BUILD_DIR }}
        run: |
          # Create build script with error handling
          cat > build.sh << 'EOF'
          #!/bin/bash
          set -eo pipefail
          
          # Redirect output to both console and log file
          exec > >(tee -a build.log) 2>&1
          
          echo "Starting live-build process at $(date)"
          
          # Run the build with appropriate error handling
          if [ -f "auto/build" ]; then
            ./auto/build
          else
            lb build
          fi
          
          # Verify ISO was created
          if ls live-image-*.iso 1> /dev/null 2>&1; then
            echo "ISO build successful!"
            # Rename ISO to standard name
            for iso in live-image-*.iso; do
              mv "$iso" "../${{ env.ISO_NAME }}.iso"
              echo "::set-output name=iso_path::${{ env.BUILD_DIR }}/../${{ env.ISO_NAME }}.iso"
              echo "::set-output name=iso_name::${{ env.ISO_NAME }}.iso"
              break
            done
          else
            echo "::error::ISO build failed! No ISO file found."
            exit 1
          fi
          EOF
          
          chmod +x build.sh
          
          # Run build with timeout for safety
          timeout 90m ./build.sh || {
            echo "::error::Build failed or timed out after 90 minutes"
            
            # Capture build logs even on failure
            if [ -f "build.log" ]; then
              cp build.log ${{ github.workspace }}/build.log
            fi
            
            # Check for common issues
            if grep -q "E: You don't have enough free space" build.log; then
              echo "::error::Build failed due to insufficient disk space"
            elif grep -q "E: Failed to fetch" build.log; then
              echo "::error::Build failed due to network issues"
            fi
            
            exit 1
          }

      # Calculate checksums for the ISO
      - name: Generate checksums
        run: |
          ISO_PATH="${{ env.BUILD_DIR }}/../${{ env.ISO_NAME }}.iso"
          if [ -f "$ISO_PATH" ]; then
            cd $(dirname "$ISO_PATH")
            sha256sum "${{ env.ISO_NAME }}.iso" > "${{ env.ISO_NAME }}.sha256sum"
            echo "::notice::ISO checksum generated successfully"
          else
            echo "::error::ISO file not found at expected location"
            exit 1
          fi

      # Upload build logs
      - name: Upload build logs
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: build-logs
          path: |
            ${{ env.BUILD_DIR }}/build.log
            ${{ env.BUILD_DIR }}/chroot.packages.live
            ${{ env.BUILD_DIR }}/.build/
          retention-days: 7

      # Upload the ISO artifact
      - name: Upload ISO artifact
        uses: actions/upload-artifact@v3
        with:
          name: ${{ env.ISO_NAME }}
          path: |
            ${{ env.BUILD_DIR }}/../${{ env.ISO_NAME }}.iso
            ${{ env.BUILD_DIR }}/../${{ env.ISO_NAME }}.sha256sum
          retention-days: 30

      # Create GitHub Release for tagged builds
      - name: Create Release
        if: startsWith(github.ref, 'refs/tags/')
        uses: softprops/action-gh-release@v1
        with:
          files: |
            ${{ env.BUILD_DIR }}/../${{ env.ISO_NAME }}.iso
            ${{ env.BUILD_DIR }}/../${{ env.ISO_NAME }}.sha256sum
          draft: false
          prerelease: false
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}